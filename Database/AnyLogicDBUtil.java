import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.usermodel.WorkbookFactory;

/**
 * Utility helper to work with AnyLogic's internal database.
 * <p>
 * The internal database is essentially a regular JDBC database (e.g. H2 or SQLite).
 * This class demonstrates how one might create tables and store values from
 * {@link Databank} in that database.
 */
public class AnyLogicDBUtil {

    /**
     * Opens a connection to the internal database. For simplicity this
     * example uses an in-memory SQLite database. In an actual AnyLogic
     * model you would use the provided database connection URL.
     */
    public static Connection openConnection() throws SQLException {
        // In a real AnyLogic model the JDBC URL is provided by the engine
        return DriverManager.getConnection("jdbc:sqlite::memory:");
    }

    /**
     * Opens a connection using the provided JDBC URL.
     */
    public static Connection openConnection(String url) throws SQLException {
        return DriverManager.getConnection(url);
    }

    /**
     * Convenience method to connect to a running HSQLDB instance.
     * The connection string is based on the one provided in the README.
     */
    public static Connection openHSQLDBConnection() throws SQLException {
        String url = "jdbc:hsqldb:hsql://localhost:9001/test;file:/Users/merluee/Models/Test/database/db";
        return DriverManager.getConnection(url, "SA", "");
    }

    /**
     * Creates the schema used to persist {@link Databank} information.
     */
    public static void createSchema(Connection conn) throws SQLException {
        try (Statement st = conn.createStatement()) {
            st.executeUpdate(
                "CREATE TABLE IF NOT EXISTS databank (" +
                "id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
                "name VARCHAR(255), " +
                "electricityPrice DOUBLE" +
                ")");
        }
    }

    /**
     * Inserts a new databank entry into the database.
     */
    public static void insertDatabank(Connection conn, String name, Databank data) throws SQLException {
        String sql = "INSERT INTO databank(name, electricityPrice) VALUES (?, ?)";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, name);
            ps.setDouble(2, data.getElectricityPrice());
            ps.executeUpdate();
        }
    }

    /**
     * Reads the electricity price for the given databank entry.
     */
    public static double loadElectricityPrice(Connection conn, String name) throws SQLException {
        String sql = "SELECT electricityPrice FROM databank WHERE name = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, name);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next() ? rs.getDouble(1) : 0;
            }
        }
    }

    /**
     * Imports the given CSV or Excel file into a newly created table.
     * <p>
     * The first row must contain the column headers. Columns are created as
     * {@code VARCHAR(255)}. Unsupported characters in column names are removed
     * and whitespace is replaced with underscores.
     *
     * @param conn the database connection
     * @param tableName the name of the table to create
     * @param file the CSV or Excel file to import
     */
    public static void importTableFromFile(Connection conn, String tableName, File file)
            throws SQLException, IOException {
        List<String[]> rows = readFile(file);
        if (rows.isEmpty()) {
            return;
        }

        String[] headers = rows.get(0);
        try (Statement st = conn.createStatement()) {
            st.executeUpdate(buildCreateStatement(tableName, headers));
        }

        String insert = buildInsertStatement(tableName, headers.length);
        try (PreparedStatement ps = conn.prepareStatement(insert)) {
            for (int i = 1; i < rows.size(); i++) {
                String[] data = rows.get(i);
                for (int c = 0; c < headers.length; c++) {
                    String value = c < data.length ? data[c] : null;
                    ps.setString(c + 1, value);
                }
                ps.executeUpdate();
            }
        }
    }

    private static List<String[]> readFile(File file) throws IOException {
        String name = file.getName().toLowerCase();
        if (name.endsWith(".csv")) {
            return readCsv(file);
        }
        if (name.endsWith(".xls") || name.endsWith(".xlsx")) {
            return readExcel(file);
        }
        throw new IOException("Unsupported file type: " + file);
    }

    private static List<String[]> readCsv(File file) throws IOException {
        List<String[]> rows = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = br.readLine()) != null) {
                rows.add(line.split(","));
            }
        }
        return rows;
    }

    private static List<String[]> readExcel(File file) throws IOException {
        List<String[]> rows = new ArrayList<>();
        try (InputStream in = new FileInputStream(file); Workbook wb = WorkbookFactory.create(in)) {
            Sheet sheet = wb.getSheetAt(0);
            for (Row row : sheet) {
                List<String> values = new ArrayList<>();
                for (Cell cell : row) {
                    values.add(cell.toString());
                }
                rows.add(values.toArray(new String[0]));
            }
        }
        return rows;
    }

    private static String buildCreateStatement(String tableName, String[] headers) {
        StringBuilder sb = new StringBuilder();
        sb.append("CREATE TABLE IF NOT EXISTS ").append(tableName).append(" (");
        for (int i = 0; i < headers.length; i++) {
            if (i > 0) {
                sb.append(", ");
            }
            sb.append(sanitize(headers[i])).append(" VARCHAR(255)");
        }
        sb.append(")");
        return sb.toString();
    }

    private static String buildInsertStatement(String table, int columns) {
        StringBuilder sb = new StringBuilder();
        sb.append("INSERT INTO ").append(table).append(" VALUES (");
        sb.append(String.join(",", Collections.nCopies(columns, "?")));
        sb.append(")");
        return sb.toString();
    }

    private static String sanitize(String header) {
        String name = header.trim().replaceAll("\\s+", "_")
                .replaceAll("[^A-Za-z0-9_]", "");
        if (name.isEmpty() || Character.isDigit(name.charAt(0))) {
            name = "c_" + name;
        }
        return name;
    }
}
